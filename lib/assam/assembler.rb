module Assam
  class Assembler
    def initialize processor, program
      @processor = processor
      @program   = program
      @address   = 0
      @labels    = {}
    end

    def assemble
      bytecodes = @program.instructions.map do |name, *args|
        if name == :label
          # As we skip through the code, labels will just be set to the current
          # relative address of the assembled program, exactly where the next
          # instruction will be located.
          @labels[args.first] = @address
        else
          instruction = @processor.instruction_set.instructions[name]

          if instruction.nil?
            raise "No such instruction: #{name}"
          end

          if args.size != instruction[:args]
            raise "Wrong number of args for #{name}: got #{args.size} expected " +
              "#{instruction[:args]}"
          end

          # Welcome to the genius/madness that is my assembler.
          #
          # Symbols are labels. Check the @labels hash for a relative program
          # address and store it as an immediate.
          #
          # A Register represents a... well, register. Store the type code for
          # registers and then the register's opcode.
          #
          # Arrays are memory references.
          #
          # Immediates are direct numerical values, the size of which are
          # dictated by what operation is being assembled.
          args.map! do |arg|
            case arg
            when Symbol
              assemble_label arg, instruction
            when Register
              assemble_register arg, instruction
            when Array
              assemble_external arg.first, instruction
            else
              assemble_direct arg, instruction
            end
          end

          binary = [instruction[:opcode]].pack("C") + args.join('')

          Assam.logger.debug "Binary for #{name}: #{binary.unpack("C*")}"
          @address += binary.length
          binary
        end
      end

      bytecodes.join
    end

    def assemble_direct arg, instruction
      type = [Processor::IMMEDIATE].pack("C")
      data = [arg].pack(Utils.pack_for(instruction[:argsize]))

      type + data
    end

    def assemble_register arg, instruction
      type = [Processor::REGISTER].pack("C")
      data = [arg.opcode].pack("C")

      type + data
    end

    def assemble_label arg, instruction
      type = [Processor::IMMEDIATE].pack("C")
      data = [@labels[arg]].pack(Utils.pack_for(@processor.address_size))

      type + data
    end

    # Assembling external memory references is difficult due to how many
    # different types of addressing modes there are. The following is a summary
    # of the different types of binary generated by each type of addressing
    # mode:
    #
    #   # a_size = number of bytes in an address
    #
    #   [0x4000] #=> direct
    #   # generates: ext | direct | 0x4000
    #   #      size: 1   | 1      | a_size
    #
    #   [@reg] #=> register
    #   # generates: ext | reg | @reg.opcode
    #   #      size: 1   | 1   | 1
    #
    #   [@reg + 2] #=> register + offset
    #   # ext | expr | size | reg | @reg.opcode | + | offset
    #   # 1   | 1    | 1    | 1   | 1           | 1 | a_size
    #
    #   [@reg * 4 + 2] #=> register * index + offset
    #   # ext | expr | size | register | @reg.opcode | * | direct | index  | direct | offset
    #   # 1   | 1    | 1    | 1        | 1           | 1 | 1      | a_size | 1      | a_size
    #
    #   [@reg + @reg2] #=> register + register
    #   # ext | expr | size | register | @reg.opcode | + | register | @reg.opcode
    #   # 1   | 1    | 1    | 1        | 1           | 1 | 1        | 1
    #
    #   [@reg + @reg2 * 4 + 2] #=> register + register * index + offset
    #   # ext | expr | size | register | @reg.opcode | + | register | @reg.opcode | * | direct | index  | direct | offset
    #   # 1   | 1    | 1    | 1        | 1           | 1 | 1        | 1           | 1 | 1      | a_size | 1      | a_size
    #
    # Yes, this is terrifying. It can probably be done better. TODO: Read around
    # the topic of machine code to figure out how the pros do this.
    def assemble_external expression, instruction
      type = [Processor::EXTERNAL].pack("C")
      binary = nil

      if expression.is_a? MemoryExpression or expression.is_a? Array
        expression = MemoryExpression.flatten(expression)
        expression = expression.map do |elem|
          if elem.is_a? Register
            _type = [Processor::REGISTER].pack("C")
            _data = [elem.opcode].pack("C")

            _type + _data
          elsif elem.is_a? Symbol
            case elem
            when :+
              [Processor::MEM_ADD].pack("C")
            when :-
              [Processor::MEM_SUB].pack("C")
            when :*
              [Processor::MEM_MUL].pack("C")
            end
          else
            _type = [Processor::DIRECT].pack("C")
            _data = [elem].pack(Utils.pack_for(@processor.address_size))

            _type + _data
          end
        end.join

        _type = [Processor::EXPRESSION].pack("C")
        _size = [expression.length].pack("C")
        binary = _type + _size + expression
      elsif expression.is_a? Register
        _type = [Processor::REGISTER].pack("C")
        _data = [expression.opcode].pack("C")

        binary = _type + _data
      else
        _type = [Processor::DIRECT].pack("C")
        _data = [expression].pack(Utils.pack_for(@processor.address_size))

        binary = _type + _data
      end

      type + binary
    end
  end
end
